package org.jsmart.zerocode.core.httpclient.oauth2;

import java.util.Map;
import java.util.Timer;

import org.apache.http.client.methods.RequestBuilder;
import org.jsmart.zerocode.core.httpclient.BasicHttpClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.inject.Inject;
import com.google.inject.name.Named;

/**
 * @author santhoshTpixler
 *
 */


/*
 * Note: This implementation supports the OAuth2.0 with refresh_token and access token
 * 
 * Reference: https://tools.ietf.org/html/rfc6749#page-11
 * 
 * 	REFRESH TOKEN
 *  1. The refresh_token, access_token URL, client_id, grant_type and client_secret
 *     should be generated by the user and stored in the properties file specified by @TargetEnv("host.properties"),
 *     located at: http-testing/src/test/java/org/jsmart/zerocode/testhelp/tests/OAuth2/OAuth2Test_refreshToken.java
 *  2. The grant_type should be set to refresh_token in the properties file.
 *  3. For generating the refresh token REST Client such as Insomnia (https://insomnia.rest/) can
 *  	be used.
 *
 * Note: Postman cannot be used as it does not show the refresh token.
 *
 * 	ACCESS TOKEN
 * 	1. The access_token URL, client_id, grant_type, and client_secret should be generated
 *     by the user and stored in the properties file specified by @TargetEnv("host.properties"),
 *     located at: http-testing/src/test/java/org/jsmart/zerocode/testhelp/tests/OAuth2/OAuth2Test_accessToken.java.
 *  2. The grant_type should be set to client_credentials in the properties file.
 */
public class OAuth2HttpClient extends BasicHttpClient {

	private static final Logger LOGGER = LoggerFactory.getLogger(OAuth2HttpClient.class);

	/*
	 * Properties to be fetched from the host.properties
	 */
	private static final String CLIENT_ID = "client_id";
	private static final String CLIENT_SECRET = "client_secret";
	private static final String REFRESH_TOKEN = "refresh_token";
	private static final String ACCESS_TOKEN_URL = "access_token_url";
	private static final String GRANT_TYPE = "grant_type";
	/*
	 * If the Authorization header contains the replacement value as specified by the 
	 * below constant, then it is replaced with the valid access token
	 */
	private static final String ACCESS_TOKEN_REPLACEMENT_VALUE = "DIY";
	/*
	 * Time interval in which the accessToken should be renewed
	 */
	private static final long REFRESH_INTERVAL = 3540000;

	private OAuth2Impl oauth2 = null;

	@Inject
	public OAuth2HttpClient(@Named(CLIENT_ID) String clientId, @Named(CLIENT_SECRET) String clientSecret,
			@Named(REFRESH_TOKEN) String refreshToken, @Named(ACCESS_TOKEN_URL) String accountsURL, @Named(GRANT_TYPE) String grant_type) {
		if ("refresh_token".equals(grant_type)) {
			/*
			 * REFRESH TOKEN WORKFLOW
			 * generating access token using refresh tokens
			 */
			this.oauth2 = new OAuth2Impl(clientId, clientSecret, refreshToken, accountsURL, grant_type);
			Timer timer = new Timer();
			/*
			 * A Timer is started to periodically execute the OAuth2Impl's run() method,
			 * which will refresh the access token at intervals defined by REFRESH_INTERVAL
			 */
			timer.schedule(oauth2, 0, REFRESH_INTERVAL);
			synchronized (oauth2) {
				try {
					// to ensure the access token is generated before proceeding.
					oauth2.wait();
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
				}
			}
		} else if ("client_credentials".equals(grant_type)) {
			/*
			 * ACCESS TOKEN WORKFLOW
			 * Fetching access token from host.properties
			 */
			this.oauth2 = new OAuth2Impl(clientId, clientSecret, accountsURL, grant_type);
			oauth2.run();
		}
		else {
			LOGGER.info("Incorrect grant_type in properties file");
		}
	}
	
	@Override
	public RequestBuilder handleHeaders(Map<String, Object> headers, RequestBuilder requestBuilder) {
		String authorization = (String) headers.get("Authorization");
		if (authorization != null && authorization.equals(ACCESS_TOKEN_REPLACEMENT_VALUE)) {
			headers.put("Authorization", oauth2.getAccessToken());
			LOGGER.info("Token injected into header.");
		}
		return super.handleHeaders(headers, requestBuilder);
	}
}
